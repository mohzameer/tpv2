# Specification: Tag-Based Routing for Documents

## Overview
Transform document linking to be **point-based** - all links point to specific positions (anchors/tags) within documents, never to documents in general. Tags are auto-generated from headings and "document start", making every link intentional and precise. Tags are private to the user who created them.

## Background
The current document linking system allows users to create links to other documents, but always navigates to the top of the target document. This spec transforms the mental model: **links always point to a specific position** within a document. "Document top" is treated as just another point/anchor, alongside auto-generated tags from headings.

## Core Philosophy
**Every link is a link to a point, not a document.**  
Documents are just containers for points. Users must choose which point to link to - even if it's just "document start".

## Goals
1. **Mandatory point selection** - Users must select a specific point when creating links
2. Auto-generate tags from heading blocks + "document start" point
3. Enable linking to specific tags when creating document links
4. Navigate directly to tagged positions when following links
5. Maintain privacy - tags and tagged links are private to the creator
6. Provide graceful fallback when tags are not found

## Non-Goals (For Now)
- Tag-based routing for drawings (future enhancement)
- Shared/public tags visible to all users
- Tag management UI (manual creation of tags - auto-generation only in MVP)
- Tag migration when blocks are edited/deleted
- Visual tag indicators in document margin

---

## 1. Data Model

### 1.1 Database Schema

#### New Column: `document_tags`
Add a new JSONB column to the `documents` table to store tags:

```sql
ALTER TABLE documents 
ADD COLUMN IF NOT EXISTS document_tags JSONB DEFAULT '[]';

-- Add index for querying tags
CREATE INDEX IF NOT EXISTS idx_documents_tags ON documents USING GIN (document_tags);

-- Add comment
COMMENT ON COLUMN documents.document_tags IS 'Array of tags/anchors within the document for deep linking';
```

### 1.2 Tag Data Structure

Each tag is stored as a JSON object in the `document_tags` array:

```typescript
interface DocumentTag {
  id: string;                    // Unique ID (e.g., 'autotag-block123' or 'tag-abc123')
  label: string;                 // Display label (heading text or user-defined)
  blockId: string;               // BlockNote block ID to scroll to
  position: number;              // Block index in document (for ordering)
  createdAt: string;             // ISO timestamp
  createdBy: string;             // User ID who created it
  isAutoGenerated: boolean;      // true for auto-generated from headings
  headingLevel?: number;         // 1-3 for heading tags (optional)
  color?: string;                // Visual indicator color (optional)
}
```

**Example:**
```json
[
  {
    "id": "autotag-block-h1-intro",
    "label": "Introduction",
    "blockId": "block_abc123",
    "position": 0,
    "createdAt": "2026-01-19T10:00:00Z",
    "createdBy": "user_xyz",
    "isAutoGenerated": true,
    "headingLevel": 1,
    "color": "#4dabf7"
  },
  {
    "id": "autotag-block-h2-methods",
    "label": "Methods and Approach",
    "blockId": "block_def456",
    "position": 5,
    "createdAt": "2026-01-19T10:05:00Z",
    "createdBy": "user_xyz",
    "isAutoGenerated": true,
    "headingLevel": 2,
    "color": "#51cf66"
  }
]
```

### 1.3 Enhanced Document Link Structure

Extend the existing `DocumentLink` interface to support tag targeting:

```typescript
interface DocumentLink {
  // Existing fields
  id: string;
  targetDocumentId: number;
  targetDocumentNumber: number;
  targetProjectId: string;
  type: 'document' | 'drawing';
  title: string;
  x: number;
  y: number;
  adjustedY?: number;
  createdAt: string;
  
  // NEW: Tag-based routing fields (REQUIRED - every link points to a tag)
  targetTagId: string;           // ID of the tag to navigate to (ALWAYS set)
  targetTagLabel: string;        // Label of the tag for display (ALWAYS set)
  
  // NEW: Privacy fields
  createdBy?: string;            // User ID who created this link (for future privacy filtering)
}
```

**Example Document Link with Tag:**
```json
{
  "id": "link-1",
  "targetDocumentId": 42,
  "targetDocumentNumber": 5,
  "targetProjectId": "proj123",
  "type": "document",
  "title": "Research Notes",
  "x": 20,
  "y": 150,
  "adjustedY": 0,
  "createdAt": "2026-01-19T10:30:00Z",
  "targetTagId": "autotag-block-h2-methods",
  "targetTagLabel": "Methods and Approach",
  "createdBy": "user_xyz"
}
```

---

## 2. Auto-Tag Generation

### 2.1 When to Generate Tags

Auto-tags are generated from heading blocks at the following times:
1. **On document save** - After content is saved, scan for headings and update tags
2. **On document load** - Ensure tags are up-to-date when document is opened (optional, may be redundant)

### 2.2 Tag Generation Rules

1. **Always generate "Document start" tag** - Special tag at position 0
2. **Heading blocks** generate auto-tags (h1, h2, h3)
3. **Tag ID format**: 
   - Document start: `doc-start`
   - Headings: `autotag-{blockId}`
4. **Tag label**: 
   - Document start: "Document start"
   - Headings: Extracted text content from the heading block
5. **Empty headings**: Skipped (no tag created)
6. **Duplicate labels**: Allowed (multiple headings can have same text)
7. **Position**: Block index in the document array

### 2.3 Tag Generation Algorithm

```javascript
function generateAutoTags(editorDocument, userId) {
  const tags = []
  
  // ALWAYS add "Document start" tag as first tag
  const firstBlockId = editorDocument[0]?.id || 'start'
  tags.push({
    id: 'doc-start',
    label: 'Document start',
    blockId: firstBlockId,
    position: 0,
    createdAt: new Date().toISOString(),
    createdBy: userId,
    isAutoGenerated: true,
    color: '#868e96' // gray
  })
  
  // Then add heading tags
  editorDocument.forEach((block, index) => {
    // Only process heading blocks
    if (block.type === 'heading') {
      const headingText = extractBlockText(block)
      
      // Skip empty headings
      if (!headingText.trim()) {
        return
      }
      
      tags.push({
        id: `autotag-${block.id}`,
        label: headingText.trim(),
        blockId: block.id,
        position: index,
        createdAt: new Date().toISOString(),
        createdBy: userId,
        isAutoGenerated: true,
        headingLevel: block.props?.level || 1,
        color: getHeadingColor(block.props?.level || 1)
      })
    }
  })
  
  return tags
}

function extractBlockText(block) {
  if (!block.content) return ''
  if (Array.isArray(block.content)) {
    return block.content.map(c => c.text || c).join('')
  }
  return String(block.content)
}

function getHeadingColor(level) {
  const colors = {
    1: '#4dabf7', // blue (h1)
    2: '#51cf66', // green (h2)
    3: '#ffa94d', // orange (h3)
  }
  return colors[level] || '#868e96'
}
```

### 2.4 Tag Persistence

- Auto-tags **replace all existing auto-tags** on each save
- Manual tags (future) are preserved and merged with auto-tags
- Tags are stored in `document_tags` column alongside document content

**Merge Logic:**
```javascript
// On save
const autoTags = generateAutoTags(editor.document, user?.id)
const manualTags = existingTags.filter(t => !t.isAutoGenerated)
const mergedTags = [...manualTags, ...autoTags]

await updateDocumentTags(docId, mergedTags)
```

---

## 3. User Experience Flow

### 3.1 Creating a Point-Based Link

**Previous Flow:**
1. User clicks floating link button → Modal opens
2. User selects project → Documents list shows
3. User selects document → Link created at position
4. Link navigates to top of target document

**New Flow (Point-Based, Tag Selection REQUIRED):**
1. User clicks floating link button → Modal opens
2. User selects project → Documents list shows
3. User selects document → **Tag selection step ALWAYS appears**
4. Modal shows available points/tags from selected document:
   - **"Document start" (always present, auto-selected)**
   - Auto-generated tags from headings (grouped by level)
5. **User must select a point** (or accept default "Document start")
6. Link created with `targetTagId` and `targetTagLabel`
7. Link **always** navigates to specific point in target document

**Modal UI - Tag Selection Step:**

```
┌───────────────────────────────────────────┐
│  ← Back    Link to: "Research Notes"      │
├───────────────────────────────────────────┤
│                                            │
│  Select point in document:                 │
│                                            │
│  ●  Document start (default)               │
│                                            │
│  Headings:                                 │
│  ○  Introduction                    (H1)   │
│  ○  Background                      (H2)   │
│  ○  Methods and Approach            (H2)   │
│  ○  Results                         (H2)   │
│  ○  Conclusion                      (H1)   │
│                                            │
│  (Future: Manual Tags/Anchors section)     │
│                                            │
│              [Cancel]  [Create Link]       │
└───────────────────────────────────────────┘

Note: "Document start" is pre-selected. User can 
change selection or proceed with default.
```

### 3.2 Navigating to Tagged Position

**When user clicks a link button:**

1. **Extract navigation data** from link:
   - `targetProjectId`, `targetDocumentNumber`, `targetTagId`

2. **Navigate to document**:
   - Route: `/{projectId}/{documentNumber}?tag={tagId}`
   - Example: `/proj123/5?tag=autotag-block-h2-methods`

3. **On document load** (in NotesPanel):
   - Parse URL parameter `?tag=tagId`
   - Wait for document content to load
   - Wait for tags to be available
   - Find tag in `document_tags` array
   - Find corresponding block in editor document
   - Scroll to block and highlight briefly

**Scroll & Highlight Logic:**
```javascript
function scrollToTag(tagId, editor, tags) {
  // Find tag
  const tag = tags.find(t => t.id === tagId)
  if (!tag) {
    console.warn(`Tag ${tagId} not found`)
    return
  }
  
  // Find block in editor
  const block = editor.document.find(b => b.id === tag.blockId)
  if (!block) {
    console.warn(`Block ${tag.blockId} not found for tag ${tagId}`)
    return
  }
  
  // Scroll to block
  setTimeout(() => {
    editor.setTextCursorPosition(block.id, 'start')
    
    // Visual highlight
    const blockEl = document.querySelector(`[data-node-id="${block.id}"]`)
    if (blockEl) {
      blockEl.scrollIntoView({ 
        behavior: 'smooth', 
        block: 'center' 
      })
      
      // Brief highlight animation
      blockEl.style.backgroundColor = 'rgba(74, 171, 247, 0.2)'
      setTimeout(() => {
        blockEl.style.backgroundColor = ''
      }, 1500)
    }
  }, 300)
}
```

### 3.3 Visual Indicators

**Link Button Tooltip:**
All links now show the point they navigate to:
- **Document start**: "Research Notes → Document start"
- **Heading tag**: "Research Notes → Methods and Approach"
- **Future manual tag**: "Research Notes → Key Finding"

**Link Button Icon:**
- No change needed - all links are now point-based
- Could consider different icon for "document start" vs headings (future)

---

## 4. API Functions

### 4.1 New Functions in `src/lib/api.js`

```javascript
/**
 * Get tags for a specific document
 * @param {number} documentId - Document ID
 * @returns {Promise<DocumentTag[]>} Array of tags
 */
export async function getDocumentTags(documentId) {
  const { data, error } = await supabase
    .from('documents')
    .select('document_tags, id')
    .eq('id', documentId)
    .single()
  
  if (error) {
    console.error('Failed to get document tags:', error)
    throw error
  }
  
  return data?.document_tags || []
}

/**
 * Update document tags
 * @param {number} documentId - Document ID
 * @param {DocumentTag[]} tags - Array of tags to save
 * @returns {Promise<object>} Updated document data
 */
export async function updateDocumentTags(documentId, tags) {
  const { data, error } = await supabase
    .from('documents')
    .update({ document_tags: tags })
    .eq('id', documentId)
    .select()
    .single()
  
  if (error) {
    // Handle PGRST204 schema cache error gracefully
    if (error.code === 'PGRST204') {
      console.warn('Schema cache error updating tags, tags may not be saved')
      return { success: false, tags_skipped: true }
    }
    throw error
  }
  
  return data
}

/**
 * Generate auto-tags from heading blocks in editor document
 * Always includes "Document start" as first tag
 * @param {Block[]} editorDocument - BlockNote document array
 * @param {string} userId - User ID creating the tags
 * @returns {DocumentTag[]} Array of generated tags
 */
export function generateAutoTags(editorDocument, userId) {
  const tags = []
  
  // ALWAYS add "Document start" tag first
  const firstBlockId = editorDocument[0]?.id || 'start'
  tags.push({
    id: 'doc-start',
    label: 'Document start',
    blockId: firstBlockId,
    position: 0,
    createdAt: new Date().toISOString(),
    createdBy: userId || 'guest',
    isAutoGenerated: true,
    color: '#868e96' // gray
  })
  
  // Then add heading tags
  editorDocument.forEach((block, index) => {
    if (block.type === 'heading') {
      const headingText = extractBlockText(block)
      
      if (headingText.trim()) {
        tags.push({
          id: `autotag-${block.id}`,
          label: headingText.trim(),
          blockId: block.id,
          position: index,
          createdAt: new Date().toISOString(),
          createdBy: userId || 'guest',
          isAutoGenerated: true,
          headingLevel: block.props?.level || 1,
          color: getHeadingColor(block.props?.level || 1)
        })
      }
    }
  })
  
  return tags
}

function extractBlockText(block) {
  if (!block.content) return ''
  if (Array.isArray(block.content)) {
    return block.content.map(c => c.text || c).join('')
  }
  return String(block.content)
}

function getHeadingColor(level) {
  const colors = {
    1: '#4dabf7', // blue
    2: '#51cf66', // green
    3: '#ffa94d', // orange
  }
  return colors[level] || '#868e96'
}
```

### 4.2 Enhanced Existing Functions

**Modify `getDocumentContent()` to include tags:**
```javascript
// Already returns all columns including document_tags
// No changes needed - tags will be included automatically
```

---

## 5. Component Changes

### 5.1 NotesPanel.jsx

**New State:**
```javascript
const [tags, setTags] = useState([]) // Document tags
```

**Load Tags on Document Open:**
```javascript
async function loadContent() {
  try {
    const content = await getDocumentContent(docId)
    if (!content) {
      setLoading(false)
      return
    }
    
    // ... existing notes_content loading ...
    
    // Load document tags
    if (content.document_tags && Array.isArray(content.document_tags)) {
      setTags(content.document_tags)
    } else {
      setTags([])
    }
    
    // ... existing code ...
  } catch (err) {
    console.error('Failed to load notes:', err)
  } finally {
    setLoading(false)
  }
}
```

**Generate and Save Tags on Content Save:**
```javascript
async function saveContent() {
  if (!docId) return
  const currentContent = JSON.stringify(editor.document)
  if (currentContent === lastSavedContent.current) return
  
  try {
    setIsSyncing(true)
    
    // Save content
    await updateDocumentContent(docId, { notes_content: editor.document })
    lastSavedContent.current = currentContent
    
    // Generate auto-tags from headings
    const autoTags = generateAutoTags(editor.document, user?.id)
    
    // Merge with existing manual tags (none for now, but future-proof)
    const manualTags = tags.filter(t => !t.isAutoGenerated)
    const mergedTags = [...manualTags, ...autoTags]
    
    // Save tags if changed
    if (JSON.stringify(mergedTags) !== JSON.stringify(tags)) {
      setTags(mergedTags)
      await updateDocumentTags(docId, mergedTags)
    }
  } catch (err) {
    console.error('Failed to save notes:', err)
  } finally {
    setIsSyncing(false)
  }
}
```

**Scroll to Tag from URL Parameter:**
```javascript
// Add useEffect to handle tag navigation from URL
useEffect(() => {
  if (!editor || loading || tags.length === 0) return
  
  // Parse tag from URL
  const urlParams = new URLSearchParams(window.location.search)
  const targetTagId = urlParams.get('tag')
  
  if (targetTagId) {
    scrollToTag(targetTagId)
    
    // Clean up URL (remove tag parameter after navigation)
    window.history.replaceState(
      {},
      '',
      window.location.pathname
    )
  }
}, [tags, editor, loading])

function scrollToTag(tagId) {
  const tag = tags.find(t => t.id === tagId)
  if (!tag) {
    console.warn(`Tag "${tagId}" not found, showing document top`)
    // Could show a subtle notification here
    return
  }
  
  // Find block in editor
  const block = editor.document.find(b => b.id === tag.blockId)
  if (!block) {
    console.warn(`Block for tag "${tagId}" not found`)
    return
  }
  
  // Scroll to block
  setTimeout(() => {
    editor.setTextCursorPosition(block.id, 'start')
    
    // Visual highlight
    const blockEl = document.querySelector(`[data-node-id="${block.id}"]`)
    if (blockEl) {
      blockEl.scrollIntoView({ behavior: 'smooth', block: 'center' })
      
      // Brief highlight animation
      blockEl.style.backgroundColor = 'rgba(74, 171, 247, 0.2)'
      setTimeout(() => {
        blockEl.style.backgroundColor = ''
      }, 1500)
    }
  }, 300)
}
```

**Pass Tags to Link Modal:**
```javascript
// When opening link modal after document selection, pass document ID
// so modal can fetch tags for that document
```

### 5.2 DocumentLinkModal.jsx

**New State:**
```javascript
const [viewState, setViewState] = useState('projects') // 'projects' | 'documents' | 'tags'
const [availableTags, setAvailableTags] = useState([])
const [selectedTag, setSelectedTag] = useState(null) // null = document top, or tag object
const [tagsLoading, setTagsLoading] = useState(false)
```

**Enhanced Document Selection:**
```javascript
async function handleSelectDocument(doc) {
  setSelectedProject(selectedProject) // Keep selected project
  setSelectedDocument(doc)
  
  // Load tags for this document
  setTagsLoading(true)
  try {
    const tags = await getDocumentTags(doc.id)
    setAvailableTags(tags || [])
    
    // Pre-select "Document start" as default
    const docStartTag = tags.find(t => t.id === 'doc-start')
    setSelectedTag(docStartTag || null)
  } catch (err) {
    console.error('Failed to load tags:', err)
    setAvailableTags([])
    setSelectedTag(null)
  } finally {
    setTagsLoading(false)
  }
  
  // Move to tag selection view (REQUIRED step)
  setViewState('tags')
}
```

**Tag Selection View:**
```javascript
// Render tag selection UI (REQUIRED step - user must select or accept default)
{viewState === 'tags' && (
  <Box style={{ flex: 1, overflowY: 'auto', padding: '12px', height: 0 }}>
    <Stack gap="md">
      {/* Back button */}
      <Group gap="xs">
        <ActionIcon onClick={() => setViewState('documents')}>
          <IconChevronLeft size={16} />
        </ActionIcon>
        <Text size="sm" fw={500}>
          Select point in: "{selectedDocument?.title}"
        </Text>
      </Group>
      
      {tagsLoading ? (
        <Center py="xl">
          <Loader size="sm" />
        </Center>
      ) : (
        <>
          {/* Document start (always first, pre-selected) */}
          {availableTags.find(t => t.id === 'doc-start') && (
            <Box
              onClick={() => handleSelectTag(availableTags.find(t => t.id === 'doc-start'))}
              p="sm"
              className="sidebar-item"
              data-selected={selectedTag?.id === 'doc-start'}
              style={{
                border: selectedTag?.id === 'doc-start' ? '2px solid var(--mantine-color-blue-6)' : undefined
              }}
            >
              <Group gap="xs">
                <IconArrowUp size={16} color="#868e96" />
                <Text size="sm" fw={selectedTag?.id === 'doc-start' ? 600 : 400}>
                  Document start
                </Text>
              </Group>
            </Box>
          )}
          
          {/* Heading tags */}
          {availableTags.filter(t => t.id !== 'doc-start' && t.isAutoGenerated).length > 0 && (
            <>
              <Text size="xs" c="dimmed" tt="uppercase" fw={600} mt="xs">
                Headings
              </Text>
              {availableTags
                .filter(t => t.id !== 'doc-start' && t.isAutoGenerated)
                .sort((a, b) => a.position - b.position)
                .map(tag => (
                  <Box
                    key={tag.id}
                    onClick={() => handleSelectTag(tag)}
                    p="sm"
                    className="sidebar-item"
                    data-selected={selectedTag?.id === tag.id}
                    style={{
                      border: selectedTag?.id === tag.id ? '2px solid var(--mantine-color-blue-6)' : undefined
                    }}
                  >
                    <Group gap="xs" justify="space-between">
                      <Group gap="xs">
                        <IconHash size={16} color={tag.color} />
                        <Text size="sm" fw={selectedTag?.id === tag.id ? 600 : 400}>
                          {tag.label}
                        </Text>
                      </Group>
                      <Text size="xs" c="dimmed">
                        H{tag.headingLevel}
                      </Text>
                    </Group>
                  </Box>
                ))}
            </>
          )}
          
          {/* Show message if only doc-start available */}
          {availableTags.length === 1 && availableTags[0].id === 'doc-start' && (
            <Text size="xs" c="dimmed" ta="center" mt="md">
              No headings found. Link will go to document start.
            </Text>
          )}
        </>
      )}
      
      {/* Create Link button - enabled only if a tag is selected */}
      <Group justify="flex-end" mt="md">
        <Button variant="default" onClick={onClose}>
          Cancel
        </Button>
        <Button 
          onClick={() => handleConfirmTag()}
          disabled={!selectedTag}
        >
          Create Link
        </Button>
      </Group>
    </Stack>
  </Box>
)}
```

**Tag Selection Handlers:**
```javascript
function handleSelectTag(tag) {
  // Just update selection (don't create link yet)
  setSelectedTag(tag)
}

function handleConfirmTag() {
  // Create link with selected tag (guaranteed to exist)
  if (!selectedTag) {
    console.error('No tag selected')
    return
  }
  
  if (onSelectDocument) {
    onSelectDocument(selectedDocument, selectedProject, {
      targetTagId: selectedTag.id,
      targetTagLabel: selectedTag.label
    })
  }
  
  // Reset and close
  setViewState('projects')
  setSelectedProject(null)
  setSelectedDocument(null)
  setAvailableTags([])
  setSelectedTag(null)
  onClose()
}
```

**Enhanced Callback Signature:**
```javascript
// Update prop type
interface DocumentLinkModalProps {
  opened: boolean
  onClose: () => void
  onSelectDocument: (doc: Document, project: Project, tagInfo?: {
    targetTagId?: string
    targetTagLabel?: string
  }) => void
  currentDocumentId: number
}
```

### 5.3 NotesPanel - Enhanced Link Creation

**Update `handleLinkSelected` to accept tag info:**
```javascript
function handleLinkSelected(selectedDocument, selectedProject, tagInfo) {
  if (!pendingLinkPosition || !selectedProject) return
  
  const buttonSize = 32
  const spacing = 4
  const position = pendingLinkPosition
  
  // Check overlap and create link
  if (checkOverlap(position.y, links, buttonSize, spacing)) {
    const adjustment = findNearestNonOverlappingY(position.y, links, buttonSize, spacing)
    if (adjustment !== null && Math.abs(adjustment) < buttonSize * 10) {
      createLink(selectedDocument, selectedProject, position, adjustment, tagInfo)
    }
  } else {
    createLink(selectedDocument, selectedProject, position, 0, tagInfo)
  }
  
  setPendingLinkPosition(null)
  setLinkModalOpened(false)
}

async function createLink(selectedDocument, selectedProject, position, adjustment, tagInfo) {
  // tagInfo is now REQUIRED - every link must have a target tag
  if (!tagInfo?.targetTagId || !tagInfo?.targetTagLabel) {
    console.error('Cannot create link without tag information')
    return
  }
  
  const linkType = isDrawing(selectedDocument) ? 'drawing' : 'document'
  const newLink = {
    id: `link-${linkIdCounter.current++}`,
    targetDocumentId: selectedDocument.id,
    targetDocumentNumber: selectedDocument.document_number,
    targetProjectId: selectedProject.id,
    type: linkType,
    title: selectedDocument.title || (linkType === 'document' ? 'Untitled' : 'Untitled drawing'),
    x: position.x,
    y: position.y,
    adjustedY: adjustment,
    createdAt: new Date().toISOString(),
    createdBy: user?.id,
    // Tag info is ALWAYS present
    targetTagId: tagInfo.targetTagId,
    targetTagLabel: tagInfo.targetTagLabel
  }
  
  const updatedLinks = [...links, newLink]
  setLinks(updatedLinks)
  const result = await saveLinks(updatedLinks)
  
  if (result && result.document_links_skipped) {
    setLinks(links) // Revert
  }
}
```

### 5.4 DocumentLinkButtons.jsx

**Navigation with Tag (Always Present):**
```javascript
const handleNavigate = () => {
  const targetProjectId = link.targetProjectId || project?.id
  if (!targetProjectId || !link.targetDocumentNumber) return
  
  // Every link has a targetTagId (could be 'doc-start' or a heading)
  if (!link.targetTagId) {
    console.error('Link missing targetTagId - this should not happen')
    return
  }
  
  setLastVisitedDocumentNumber(targetProjectId, link.targetDocumentNumber)
  
  // Build URL with tag parameter (ALWAYS present)
  const url = `/${targetProjectId}/${link.targetDocumentNumber}?tag=${encodeURIComponent(link.targetTagId)}`
  
  navigate(url)
}
```

**Tooltip (Always Shows Point):**
```javascript
// Every link has a targetTagLabel (point-based linking)
const tooltipText = `${link.title} → ${link.targetTagLabel}`

<button
  // ... existing props ...
  title={tooltipText}
>
```

**Menu Label (Always Shows Point):**
```javascript
<Menu.Label>
  {link.type === 'document' ? (
    <IconFile size={14} style={{ display: 'inline', marginRight: '4px' }} />
  ) : (
    <IconBrush size={14} style={{ display: 'inline', marginRight: '4px' }} />
  )}
  {link.title || 'Untitled'}
  <Text size="xs" c="dimmed" style={{ marginLeft: '4px' }}>
    → {link.targetTagLabel}
  </Text>
</Menu.Label>
```

---

## 6. Edge Cases & Error Handling

### 6.1 Tag Not Found

**Scenario:** User clicks link with `targetTagId`, but tag no longer exists in target document.

**Handling:**
1. URL includes `?tag=autotag-xyz`
2. Document loads, tags are loaded
3. `scrollToTag()` can't find tag with that ID
4. Log warning to console
5. Show document at top (default behavior)
6. Optional: Show subtle notification "Tag not found, showing document top"

### 6.2 Block Deleted/Changed

**Scenario:** Heading block is deleted or edited, changing its block ID.

**For Auto-Tags:**
- Auto-tags are regenerated on every save
- If heading is deleted, its tag disappears
- If heading text changes, tag label updates
- If heading block ID changes (unlikely with BlockNote), tag gets new ID

**Impact on Links:**
- Existing links with old `targetTagId` become invalid
- Fall back to document top (graceful degradation)
- **No automatic link update** - links retain old tag ID

**Future Enhancement:** Tag migration/update when block IDs change

### 6.3 Empty Headings

**Scenario:** User creates a heading block with no text.

**Handling:**
- `generateAutoTags()` skips empty headings
- No tag created for empty headings
- If user later adds text, tag is created on next save

### 6.4 Duplicate Heading Text

**Scenario:** Multiple headings with same text (e.g., multiple "Introduction" headings).

**Handling:**
- Each heading gets unique tag (different block IDs)
- Tags have same label but different IDs
- In tag selection UI, both appear (user sees duplicates)
- Navigation works correctly (each tag points to its specific block)

**Future Enhancement:** Add position indicator (e.g., "Introduction (1)", "Introduction (2)")

### 6.5 Performance Concerns

**Large Documents:**
- Auto-tag generation runs on every save
- For documents with 100+ headings, this may be slow
- **Mitigation:** 
  - Only generate tags for h1, h2, h3 (not h4-h6)
  - Consider debouncing tag generation
  - Cache tag generation results

**Tag Storage:**
- Tags stored as JSONB array in database
- GIN index allows fast queries
- Expected size: ~100-500 bytes per tag
- 100 tags ≈ 10-50 KB (negligible)

---

## 7. Implementation Plan

### Phase 1: Core Infrastructure ✅
**Goal:** Database setup and tag generation

1. Create database migration for `document_tags` column
2. Add API functions:
   - `getDocumentTags()`
   - `updateDocumentTags()`
   - `generateAutoTags()`
3. Integrate tag generation into `NotesPanel.saveContent()`
4. Test tag generation and persistence

**Acceptance Criteria:**
- Tags are generated from headings on save
- Tags are persisted to database
- Tags can be retrieved for any document

### Phase 2: Tag Selection UI ✅
**Goal:** Allow users to select tags when creating links

1. Enhance `DocumentLinkModal` with tag selection step
2. Add "tags" view state to modal
3. Implement tag loading after document selection
4. Create tag selection UI (list of headings)
5. Update link creation to include tag info

**Acceptance Criteria:**
- After selecting document, user sees tag selection screen
- User can choose "document top" or specific heading
- Selected tag is stored in document link

### Phase 3: Tag Navigation ✅
**Goal:** Navigate to tagged positions when clicking links

1. Update `DocumentLinkButtons` to include tag in navigation URL
2. Add URL parameter parsing in `NotesPanel`
3. Implement `scrollToTag()` function
4. Add visual highlight animation
5. Handle tag-not-found fallback

**Acceptance Criteria:**
- Clicking tagged link navigates to correct position
- Target block is highlighted briefly
- Missing tags fall back gracefully to document top

### Phase 4: Polish & Edge Cases ✅
**Goal:** Handle edge cases and improve UX

1. Enhanced tooltips showing tag labels
2. Menu labels showing tag info
3. Error handling for all edge cases
4. Performance testing with large documents
5. Documentation and testing

**Acceptance Criteria:**
- All edge cases handled gracefully
- No console errors
- Smooth navigation experience
- Documentation complete

---

## 8. Future Enhancements

### 8.1 Manual Tag Creation
- Allow users to create custom tags at any block
- UI: Right-click menu or slash command `/tag`
- Modal for entering tag label
- Visual indicator in margin (colored dot/icon)

### 8.2 Tag Management UI
- View all tags in current document
- Edit tag labels
- Delete tags
- See which links point to each tag

### 8.3 Shared Tags
- Option to make tags visible to all users
- Team/project-wide tag library
- Tag permissions (creator, editor, viewer)

### 8.4 Tag Migration
- Detect when blocks are edited/deleted
- Update tag `blockId` references
- Notify users of broken links

### 8.5 Visual Indicators
- Tag markers in document margin
- Different colors for different heading levels
- Click marker to see incoming links

### 8.6 Tag-Based Routing for Drawings
- Create anchors in Excalidraw drawings
- Link to specific elements or regions
- Navigate to specific drawing area

### 8.7 Cross-Project Tags
- Link to tags in documents in other projects
- Requires authentication and permission checks

### 8.8 Tag Search
- Search for tags across all documents
- Filter by heading level, label text
- Quick navigation to any tag

---

## 9. Testing Strategy

### 9.1 Unit Tests
- `generateAutoTags()` function
  - Empty document → empty array
  - Document with headings → correct tags
  - Mixed content → only headings tagged
  - Empty headings → skipped

### 9.2 Integration Tests
- Create document with headings → tags generated
- Create link with tag → tag info saved
- Click tagged link → navigates to correct position
- Delete heading → tag removed on next save

### 9.3 Manual Testing Checklist
- [ ] Create document with multiple headings (h1, h2, h3)
- [ ] Verify tags are generated on save
- [ ] Create link to another document
- [ ] Select a specific heading tag
- [ ] Verify link shows tag label in tooltip
- [ ] Click link and verify navigation to tagged position
- [ ] Verify highlight animation appears
- [ ] Delete tagged heading and save
- [ ] Click link again, verify fallback to document top
- [ ] Test with empty headings (should be skipped)
- [ ] Test with duplicate heading text (should work)

---

## 10. Security & Privacy

### 10.1 Privacy Considerations
- Tags contain `createdBy` field (user ID)
- Currently all tags are visible to all users viewing the document
- **Future:** Filter tags by creator for private tags

### 10.2 Link Privacy
- Links are stored in source document
- Links contain `createdBy` field (future use)
- Currently links are visible to all users viewing the source document
- **Future:** Filter links by creator for private links

### 10.3 Data Validation
- Validate tag IDs before navigation
- Sanitize tag labels (prevent XSS)
- Validate block IDs exist in document
- Validate tag array structure in database

---

## 11. Technical Notes

### 11.1 Why Auto-Generate Only (For MVP)?
Manual tag creation adds complexity:
- Need UI for tag creation (modal, context menu)
- Need visual indicators in document margin
- Need tag management UI (edit, delete)
- Need to handle tag-block associations when content changes

Auto-generation from headings + "document start" provides 90% of the value with 20% of the complexity.

### 11.2 Why Mandatory Point Selection?
Benefits of requiring point selection:
- **Clearer mental model** - Links are always to points, not documents
- **More intentional** - Users think about what they're referencing
- **Better UX** - No confusion about where link will go
- **Consistent behavior** - All links work the same way
- **Future-proof** - When manual tags are added, the flow is already established

### 11.3 Why Store Tags in `documents` Table?
- Tags are metadata about document structure
- Closely tied to document content (headings)
- Simpler schema (no separate `tags` table)
- Easier to query and update atomically with document
- JSONB provides flexibility for schema evolution

### 11.4 Why Not Use Block IDs Directly?
Block IDs can change when:
- Document is restructured
- Content is imported/exported
- BlockNote updates change ID generation

Tags provide stable references that can be updated/migrated independently of blocks.

### 11.5 Performance Considerations
- Tag generation is fast (< 10ms for 100 headings)
- Tag storage is small (< 1 KB for typical document)
- GIN index allows fast tag queries
- No performance impact expected for typical documents

---

## Appendix A: Example Usage Scenario

**User Story:**
Sarah is writing a research paper in ThinkPost. She has:
- Document A: "Research Overview" with sections: Introduction, Methods, Results, Conclusion
- Document B: "Detailed Analysis" where she wants to reference specific sections in Document A

**Steps:**
1. Sarah opens Document A and writes headings for each section
2. On save, tags are auto-generated: "Document start", "Introduction", "Methods", "Results", "Conclusion"
3. Sarah opens Document B
4. She clicks the floating link button next to a paragraph discussing methods
5. Modal opens, she selects Document A
6. **Tag selection appears (REQUIRED)** showing:
   - ● Document start (pre-selected)
   - ○ Introduction
   - ○ Methods
   - ○ Results
   - ○ Conclusion
7. She selects "Methods" and clicks "Create Link"
8. Link button appears with tooltip "Research Overview → Methods"
9. Later, when reviewing, she clicks the link
10. Document A opens and scrolls directly to the Methods section
11. The Methods heading briefly highlights to show where she landed

**Result:** Sarah can create precise cross-references between documents, making her research easier to navigate and connect.

---

## Appendix B: Data Flow Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                     Document Save Flow                       │
└─────────────────────────────────────────────────────────────┘

User edits document
      ↓
saveContent() triggered (debounced)
      ↓
Save notes_content to database
      ↓
generateAutoTags(editor.document, user.id)
      ↓
Extract headings → Create tag objects
      ↓
Merge with manual tags (if any)
      ↓
updateDocumentTags(docId, mergedTags)
      ↓
Tags saved to document_tags column


┌─────────────────────────────────────────────────────────────┐
│                    Link Creation Flow                        │
└─────────────────────────────────────────────────────────────┘

User clicks floating link button
      ↓
Modal opens → Select project
      ↓
Select document
      ↓
getDocumentTags(documentId)
      ↓
Tags loaded and displayed
      ↓
User selects tag (or "document top")
      ↓
createLink(..., tagInfo)
      ↓
Link object created with targetTagId + targetTagLabel
      ↓
saveLinks() → Update document_links array
      ↓
Link button appears with tag info


┌─────────────────────────────────────────────────────────────┐
│                    Tag Navigation Flow                       │
└─────────────────────────────────────────────────────────────┘

User clicks link button
      ↓
handleNavigate() extracts tag info
      ↓
navigate(`/${projectId}/${docNumber}?tag=${tagId}`)
      ↓
Document loads, URL parsed
      ↓
useEffect detects ?tag parameter
      ↓
scrollToTag(tagId) called
      ↓
Find tag in tags array
      ↓
Find block by blockId in editor.document
      ↓
Scroll to block + highlight
      ↓
Clean up URL (remove ?tag parameter)
```

---

**End of Specification**
